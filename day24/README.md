# 【Day 24】像使用者一樣思考：Testing Library 實戰\n\n## 聯繫我\n如果有任何問題或建議，歡迎隨時聯繫我：\n\n- [GitHub](https://github.com/Chung-Chi-Lin)\n- [Email](mailto:z0925955648@gmail.com)\n\n## 前言\n\n昨天，我們學會了如何用 `@vue/test-utils` 像個精密儀器技師一樣，檢查元件的 props、classes、和 emitted events。我們寫的測試很精準，但它們關心的是「**元件的內部實現**」。\n\n-   `expect(wrapper.classes()).toContain('is-disabled')`\n-   `expect(wrapper.emitted()).toHaveProperty('click')`\n\n這些測試很棒，但它們和你的「使用者」在乎的事情，可能有點距離。\n\n試想一下：\n\n> 一個使用者不在乎一個被禁用的按鈕是不是剛好有個叫 `is-disabled` 的 class，他只在乎「**這個按鈕我點不了**」。\n> 一個使用者不知道什麼是 `emit`，他只在乎「**我點了登入按鈕後，頁面上是不是出現了歡迎訊息**」。\n\n今天，我們要介紹一個截然不同的測試哲學與工具庫：**Testing Library**。\n\n它的核心指導原則是：\n\n> **The more your tests resemble the way your software is used, the more confidence they can give you.**\n> (你的測試越像軟體被實際使用的方式，它能帶給你的信心就越多。)\n\n打個比方，如果說昨天的我們是拿著儀器檢查引擎零件的「**技師**」，那麼今天的我們，就是坐進駕駛座，實際踩油門、打方向盤的「**試駕員**」。試駕員不關心引擎內部是 V6 還是 V8，他只關心車子能不能順暢地加速、轉彎和煞車。這種測試方式，讓我們離「確保軟體能用」這個終極目標更近了一步。\n\n## 1. Testing Library 的哲學轉變\n\nTesting Library 會刻意地「限制」你，讓你很難去測試元件的內部實現細節。它鼓勵你：\n\n1.  **像使用者一樣去查詢元素**：不是透過 `id` 或 `class`，而是透過使用者能在畫面上看到的「文字」、`label` 標籤、或是 WAI-ARIA 的 `role`。\n2.  **像使用者一樣去互動**：不是簡單地 `trigger` 一個事件，而是模擬完整的使用者操作，例如「打字」、「點擊」、「懸停」。\n3.  **像使用者一樣去斷言結果**：不是斷言某個 `data` 變成了 `true`，而是斷言畫面上是否出現了「成功」的訊息。\n\n這種轉變讓你的測試變得**更健壯、不易碎**。如果你只是重構了元件的內部結構，例如把 `<div>` 換成 `<section>`，或是改了 CSS class 的名字，只要對使用者的最終體驗沒有影響，你的測試就不會壞。這才是我們想要的！\n\n## 2. 環境設定\n\n我們需要幾個新夥伴：\n\n-   `@testing-library/vue`: Testing Library 的 Vue 版本。\n-   `@testing-library/user-event`: 一個更真實的使用者事件模擬庫。\n-   `@testing-library/jest-dom`: 提供一系列對 DOM 更友善的斷言匹配器，例如 `toBeInTheDocument()`。\n\n```bash\nnpm install -D @testing-library/vue @testing-library/user-event @testing-library/jest-dom\n```\n\n為了讓 Vitest 能使用 `jest-dom` 的匹配器，我們需要建立一個設定檔。\n\n**建立 `vitest.setup.js` 於專案根目錄：**\n```javascript\n// vitest.setup.js\nimport { expect } from \'vitest\';\nimport \`@testing-library/jest-dom/vitest\`;\n```\n\n**修改 `vite.config.js`：**\n```javascript\n// vite.config.js\n/// <reference types=\"vitest\" />\n// ...\n\nexport default defineConfig({\n  // ...\n  test: {\n    globals: true,\n    environment: \'jsdom\',\n    // 告訴 Vitest 在執行測試前先跑這個設定檔\n    setupFiles: \'./vitest.setup.js\',\n  },\n});\n```\n\n## 3. 實戰演練：測試一個登入表單\n\n沒有什麼比一個登入表單更能體現使用者互動了。讓我們來測試這個元件：\n\n```vue\n// src/components/LoginForm.vue\n<template>\n  <form @submit.prevent=\"handleSubmit\">\n    <div v-if=\"successMessage\" class=\"success\">{{ successMessage }}</div>\n    <div v-if=\"errorMessage\" role=\"alert\" class=\"error\">{{ errorMessage }}</div>\n\n    <div>\n      <label for=\"username-input\">Username</label>\n      <input id=\"username-input\" v-model=\"username\" />\n    </div>\n\n    <div>\n      <label for=\"password-input\">Password</label>\n      <input id=\"password-input\" type=\"password\" v-model=\"password\" />\n    </div>\n\n    <button type=\"submit\">Login</button>\n  </form>\n</template>\n\n<script setup>\nimport { ref } from \'vue\';\nconst username = ref(\'\');\nconst password = ref(\'\');\nconst errorMessage = ref(null);\nconst successMessage = ref(null);\n\nconst handleSubmit = () => {\n  if (username.value === \'testuser\' && password.value === \'password123\') {\n    successMessage.value = `Welcome, ${username.value}!`;\n    errorMessage.value = null;\n  } else {\n    errorMessage.value = \'Invalid username or password\';\n    successMessage.value = null;\n  }\n};\n</script>\n```\n\n現在，讓我們用「試駕員」的視角來寫測試：\n\n```javascript\n// src/components/LoginForm.spec.js\nimport { describe, it, expect } from \'vitest\';\n// 從 testing-library 引入 render 和 screen\nimport { render, screen } from \'@testing-library/vue\';\n// 引入 user-event\nimport userEvent from \'@testing-library/user-event\';\nimport LoginForm from \'./LoginForm.vue\';\n\ndescribe(\'LoginForm.vue\', () => {\n  // 準備好我們的「試駕員」\n  const user = userEvent.setup();\n\n  it(\'allows a user to log in successfully\', async () => {\n    // 1. Render: 把元件渲染到畫面上\n    render(LoginForm);\n\n    // 2. Query: 像使用者一樣，透過 Label 文字找到輸入框，透過按鈕上的文字找到按鈕\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const loginButton = screen.getByRole(\'button\', { name: /login/i });\n\n    // 3. Interact: 模擬使用者打字和點擊\n    await user.type(usernameInput, \'testuser\');\n    await user.type(passwordInput, \'password123\');\n    await user.click(loginButton);\n\n    // 4. Assert: 斷言使用者最終看到的結果\n    // 登入成功後，應該要看到歡迎訊息\n    const successMessage = await screen.findByText(/welcome, testuser/i);\n    expect(successMessage).toBeInTheDocument();\n\n    // 並且，不應該看到錯誤訊息\n    // queryBy* 在找不到元素時會回傳 null，而不是拋出錯誤\n    const errorMessage = screen.queryByRole(\'alert\');\n    expect(errorMessage).not.toBeInTheDocument();\n  });\n\n  it(\'shows an error message with invalid credentials\', async () => {\n    render(LoginForm);\n\n    await user.type(screen.getByLabelText(/username/i), \'wronguser\');\n    await user.type(screen.getByLabelText(/password/i), \'wrongpassword\');\n    await user.click(screen.getByRole(\'button\', { name: /login/i }));\n\n    // 斷言畫面上出現了錯誤訊息\n    // findBy* 會等待元素出現，適合用在非同步更新後的斷言\n    const errorMessage = await screen.findByRole(\'alert\');\n    expect(errorMessage).toBeInTheDocument();\n    expect(errorMessage).toHaveTextContent(/invalid username or password/i);\n  });\n});\n```\n\n> **Testing Library 工具箱**：\n> - `render`: 取代 `@vue/test-utils` 的 `mount`，負責渲染元件。\n> - `screen`: 你的「螢幕」，所有查詢都從這裡開始，代表著使用者當前所見。\n> - **Queries (查詢函式)**：\n>   - `getBy*`: 同步查詢，找不到就報錯。用來找一開始就該在畫面上的東西。\n>   - `findBy*`: 非同步查詢，會等待一段時間。用來找使用者操作後才出現的東西。\n>   - `queryBy*`: 同步查詢，找不到就回傳 `null`。用來檢查某個東西「不應該」在畫面上。\n> - `userEvent`: 比 `trigger` 更真實的互動模擬器。\n\n## 本篇自我挑戰\n\n1.  **安裝與設定**：跟隨文章，將 Testing Library 全家桶安裝到你的專案，並設定好 `vitest.setup.js`。\n2.  **重寫測試**：挑選一個你之前用 `@vue/test-utils` 寫的測試，試著用 Testing Library 的哲學重寫它。\n3.  **練習查詢**：在重寫時，強迫自己優先使用 `getByRole`, `getByLabelText`, `getByText`，而不是 `getByTestId`。感受一下從「使用者視角」出發的查詢方式有何不同。\n\n## 總結\n\n今天我們完成了一次重要的「心態轉變」。從關心「程式碼如何實現」的技師，變成了關心「軟體如何被使用」的試駕員。\n\n-   **Testing Library 的哲學**：讓測試更貼近使用者行為，從而獲得更高的信心。\n-   **查詢方式的轉變**：從查詢 `class` 和 `id`，轉變為查詢**文字、標籤、角色**等對使用者和輔助技術更有意義的標識。\n-   **互動方式的升級**：使用 `userEvent` 來模擬更真實的使用者輸入。\n\n採用 Testing Library 撰寫的測試，或許一開始會讓你覺得有點「繞」，但它所帶來的回報是巨大的：**一個更穩健、更具可維護性、更能反映真實使用者體驗的測試套件**。\n\n明天，我們將處理測試中的一個經典難題：如何處理外部依賴，特別是 **API 請求的 Mocking (模擬)**。\n\n## 本日關鍵字回顧\n\n-   `Testing Library`\n-   `@testing-library/vue`\n-   `@testing-library/user-event`\n-   `@testing-library/jest-dom`\n-   `實作細節 (Implementation Details)`\n-   `render / screen`\n-   `Queries (getBy / findBy / queryBy)`\n-   `可訪問性 (Accessibility, a11y)`\n-   `Role / Label`\n-   `userEvent`\n